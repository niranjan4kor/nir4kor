/********************************************************************************
 * Copyright (c) 2021-2022 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/

 syntax = "proto3";

 import "common.proto";

 package sdv.edge.databroker.collector;

 service Collector {
     // A feeder (provider) shall call this as a first step to announce its "owned" data points
     // to the Data Broker.
     // If the registration of at least one of the passed data point fails, the overall registration
     // is rejected and the gRPC status code ABORTED is returned (to indicate the "aborted" registration).
     // The details, which data point(s) caused the failure and the reason, is passed in back in human-
     // readable form in the status message. Possible failure resaons are:
     //  * PERMISSION_DENIED - Not allowed to register this name
     //  * ALREADY_REGISTERED - The data point is already registered by some other feeder
     //  * RE_REGISTRATION_MISMATCH - Already registered by this feeder but with differing metadata
     //  * INVALID_NAME - The passed name of the datapoint has an invalid structure
     //  * INVALID_VALUE_TYPE - The passed ValueType is not supported
     //  * INVALID_CHANGE_TYPE - The passed ChangeType is not supported
     rpc RegisterDatapoints(RegisterDatapointsRequest) returns (RegisterDatapointsReply);

     // TODO: Convert RegisterDatapointsReply into a stream in order to be able to communicate
     //       subscription state (i.e. if there are subscribing clients)
     // or
     //       Use a separate function (typically immediately) called after successful
     // registration of datapoints, e.g.:
     //
     // rpc GetSubscriptionStates(<list of ids>) returns (stream SubscriptionStatesReply);
     // or
     // rpc ProvideDatapoints(ProvideDatapointsRequest) returns (stream ProvideDatapointsReply);

     // A feeder calls this to feed datapoint values to the broker that are updated on a very
     // infrequent basis (e.g. less than once per second).
     rpc UpdateDatapoints(UpdateDatapointsRequest) returns (UpdateDatapointsReply);

     // A feeder calls this to feed datapoint values to the broker that are updated on a
     // frequent basis (e.g. at least once per second).
     rpc StreamDatapoints(stream StreamDatapointsRequest) returns (stream StreamDatapointsReply);
 }

 enum DatapointError {
     UNKNOWN_DATAPOINT = 0;
     INVALID_TYPE      = 1;
     ACCESS_DENIED     = 2;
     INTERNAL_ERROR    = 3;
 }

 message UpdateDatapointsRequest {
     map<int32, Datapoint> datapoints = 1;
 }

 message UpdateDatapointsReply {
     map<int32, DatapointError> errors = 1;  // If empty, everything went well
 }

 message StreamDatapointsRequest {
     map<int32, Datapoint> datapoints = 1;
 }

 message StreamDatapointsReply {
     map<int32, DatapointError> errors = 1;  // If empty, everything went well
 }

 message RegisterDatapointsRequest {
     repeated RegistrationMetadata list = 1;
 }

 message RegistrationMetadata {
     // Name of the data point consisting of elements separated by a dot '.'
     // (e.g. "Vehicle.Cabin.Seat.Row1.Pos1.Position" or "Vehicle.Speed")
     // allowing to define datapoints as a tree structure like define by
     // COVESA VSS (https://covesa.github.io/vehicle_signal_specification/).
     string name          = 1;
     ValueType value_type = 2;
     // "Free text" description allowing to give additional details targeted
     // to an app developer.
     string description     = 3;
     ChangeType change_type = 4;

     // int32             min_update_hz       = 10; // Only for CONTINUOUS
     // int32             max_update_hz       = 11; // Only for CONTINUOUS
 };

 message RegisterDatapointsReply {
     // Maps each data point name passed in RegisterDatapointsRequest to a data point id
     map<string, int32> results = 1;
 }
